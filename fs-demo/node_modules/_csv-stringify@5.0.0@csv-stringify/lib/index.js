// Generated by CoffeeScript 2.3.2
// # CSV Stringifier

// Please look at the [project documentation](https://csv.js.org/stringify/) for additional
// information.
var Stringifier, get, stream, underscore, util;

stream = require('stream');

util = require('util');

get = require('lodash.get');

// ## Usage

// This module export a function as its main entry point and return a transform
// stream.

// Refers to the [official prject documentation](http://csv.adaltas.com/stringify/)
// on how to call this function.
module.exports = function() {
  var callback, chunks, data, options, stringifier;
  if (arguments.length === 3) {
    data = arguments[0];
    options = arguments[1];
    callback = arguments[2];
  } else if (arguments.length === 2) {
    if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    } else {
      options = arguments[1];
    }
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = arguments[0];
    } else if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
  }
  if (options == null) {
    options = {};
  }
  stringifier = new Stringifier(options);
  if (data) {
    process.nextTick(function() {
      var d, j, len;
      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        stringifier.write(d);
      }
      return stringifier.end();
    });
  }
  if (callback) {
    chunks = [];
    stringifier.on('readable', function() {
      var chunk, results;
      results = [];
      while (chunk = stringifier.read()) {
        results.push(chunks.push(chunk));
      }
      return results;
    });
    stringifier.on('error', function(err) {
      return callback(err);
    });
    stringifier.on('end', function() {
      return callback(null, chunks.join(''));
    });
  }
  return stringifier;
};

// You can also use *util.promisify* native function (Node.js 8+) in order to wrap callbacks into promises for more convenient use when source is a readable stream and you are OK with storing entire result set in memory:

// ```
// const { promisify } = require('util');
// const csv = require('csv');
// const stringifyAsync = promisify(csv.stringify);

// //returns promise
// function generateCsv(sourceData) {
//     return stringifyAsync(sourceData);
// }
// ```

// ## `Stringifier([options])`

// Options are documented [here](http://csv.adaltas.com/stringify/).
Stringifier = function(opts = {}) {
  var base, base1, base2, base3, base4, isRegExp, isString, j, k, len, options, quoted_match, ref, v;
  stream.Transform.call(this, {...options, ...{
      writableObjectMode: true
    }});
  options = {};
  for (k in opts) {
    v = opts[k];
    // Immutable options and camelcase conversion
    options[underscore(k)] = v;
  }
  //# Default options
  if (options.delimiter == null) {
    options.delimiter = ',';
  }
  if (options.quote == null) {
    options.quote = '"';
  }
  if (options.quoted == null) {
    options.quoted = false;
  }
  if (options.quoted_empty == null) {
    options.quoted_empty = void 0;
  }
  if (options.quoted_string == null) {
    options.quoted_string = false;
  }
  if (options.eof == null) {
    options.eof = true;
  }
  if (options.escape == null) {
    options.escape = '"';
  }
  if (options.header == null) {
    options.header = false;
  }
  // Normalize the columns option
  options.columns = Stringifier.normalize_columns(options.columns);
  if (options.cast == null) {
    options.cast = {};
  }
  // Normalize option `quoted_match`
  if (options.quoted_match === void 0 || options.quoted_match === null || options.quoted_match === false) {
    options.quoted_match = null;
  } else if (!Array.isArray(options.quoted_match)) {
    options.quoted_match = [options.quoted_match];
  }
  if (options.quoted_match) {
    ref = options.quoted_match;
    for (j = 0, len = ref.length; j < len; j++) {
      quoted_match = ref[j];
      isString = typeof quoted_match === 'string';
      isRegExp = quoted_match instanceof RegExp;
      if (!isString && !isRegExp) {
        throw Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`);
      }
    }
  }
  if (options.cast.bool) {
    // Backward compatibility
    options.cast.boolean = options.cast.bool;
  }
  // Custom cast
  if ((base = options.cast).string == null) {
    base.string = function(value) {
      return value;
    };
  }
  if ((base1 = options.cast).date == null) {
    base1.date = function(value) {
      // Cast date to timestamp string by default
      return '' + value.getTime();
    };
  }
  if ((base2 = options.cast).boolean == null) {
    base2.boolean = function(value) {
      // Cast boolean to string by default
      if (value) {
        return '1';
      } else {
        return '';
      }
    };
  }
  if ((base3 = options.cast).number == null) {
    base3.number = function(value) {
      // Cast number to string using native casting by default
      return '' + value;
    };
  }
  if ((base4 = options.cast).object == null) {
    base4.object = function(value) {
      // Stringify object as JSON by default
      return JSON.stringify(value);
    };
  }
  if (options.record_delimiter === void 0 || options.record_delimiter === null || options.record_delimiter === false) {
    if (options.record_delimiter == null) {
      options.record_delimiter = '\n';
    }
  } else if (typeof options.record_delimiter === 'string') {
    switch (options.record_delimiter) {
      case 'auto':
        options.record_delimiter = null;
        break;
      case 'unix':
        options.record_delimiter = "\n";
        break;
      case 'mac':
        options.record_delimiter = "\r";
        break;
      case 'windows':
        options.record_delimiter = "\r\n";
        break;
      case 'ascii':
        options.record_delimiter = "\u001e";
        break;
      case 'unicode':
        options.record_delimiter = "\u2028";
    }
  } else if (Buffer.isBuffer(options.record_delimiter)) {
    options.record_delimiter = options.record_delimiter.toString();
  } else {
    throw Error(`Invalid Option: record_delimiter must be a string or a buffer, got ${JSON.stringify(options.record_delimiter)}`);
  }
  // Internal usage, state related
  if (this.countWriten == null) {
    this.countWriten = 0;
  }
  // Expose options
  this.options = options;
  return this;
};

util.inherits(Stringifier, stream.Transform);

module.exports.Stringifier = Stringifier;

// ## `Stringifier.prototype._transform(chunk, encoding, callback)`

// Implementation of the [transform._transform function](https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback).
Stringifier.prototype._transform = function(chunk, encoding, callback) {
  var base, e, preserve;
  // Nothing to do if null or undefined
  if (chunk == null) {
    return;
  }
  preserve = typeof chunk !== 'object';
  // Emit and stringify the record if an object or an array
  if (!preserve) {
    // Detect columns from the first record
    if (this.countWriten === 0 && !Array.isArray(chunk)) {
      if ((base = this.options).columns == null) {
        base.columns = Stringifier.normalize_columns(Object.keys(chunk));
      }
    }
    try {
      this.emit('record', chunk, this.countWriten);
    } catch (error) {
      e = error;
      return this.emit('error', e);
    }
    // Convert the record into a string
    if (this.options.eof) {
      chunk = this.stringify(chunk);
      if (chunk == null) {
        return;
      }
      chunk = chunk + this.options.record_delimiter;
    } else {
      chunk = this.stringify(chunk);
      if (chunk == null) {
        return;
      }
      if (this.options.header || this.countWriten) {
        chunk = this.options.record_delimiter + chunk;
      }
    }
  }
  if (typeof chunk === 'number') {
    // Emit the csv
    chunk = `${chunk}`;
  }
  if (this.countWriten === 0) {
    this.headers();
  }
  if (!preserve) {
    this.countWriten++;
  }
  this.push(chunk);
  return callback();
};

// ## `Stringifier.prototype._flush(callback)`

// Implementation of the [transform._flush function](https://nodejs.org/api/stream.html#stream_transform_flush_callback).
Stringifier.prototype._flush = function(callback) {
  if (this.countWriten === 0) {
    this.headers();
  }
  return callback();
};

// ## `Stringifier.prototype.stringify(line)`

// Convert a line to a string. Line may be an object, an array or a string.
Stringifier.prototype.stringify = function(record) {
  var _record, column, columns, containsEscape, containsQuote, containsRowDelimiter, containsdelimiter, delimiter, err, escape, field, i, j, l, newrecord, quote, quoted, quotedMatch, quotedString, ref, ref1, regexp, shouldQuote, type, value;
  if (typeof record !== 'object') {
    return record;
  }
  columns = this.options.columns;
  delimiter = this.options.delimiter;
  quote = this.options.quote;
  escape = this.options.escape;
  if (!Array.isArray(record)) {
    _record = [];
    if (columns) {
      for (i = j = 0, ref = columns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        value = get(record, columns[i].key);
        _record[i] = (typeof value === 'undefined' || value === null) ? '' : value;
      }
    } else {
      for (column in record) {
        _record.push(record[column]);
      }
    }
    record = _record;
    _record = null;
  } else if (columns) { // Note, we used to have @options.columns
    // We are getting an array but the user want specified output columns. In
    // this case, we respect the columns indexes
    record.splice(columns.length);
  }
  if (Array.isArray(record)) {
    newrecord = '';
    for (i = l = 0, ref1 = record.length; (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
      field = record[i];
      type = typeof field;
      try {
        if (type === 'string') {
          // fine 99% of the cases
          field = this.options.cast.string(field);
        } else if (type === 'number') {
          field = this.options.cast.number(field);
        } else if (type === 'boolean') {
          field = this.options.cast.boolean(field);
        } else if (field instanceof Date) {
          field = this.options.cast.date(field);
        } else if (type === 'object' && field !== null) {
          field = this.options.cast.object(field);
        }
      } catch (error) {
        err = error;
        this.emit('error', err);
        return;
      }
      if (field) {
        if (typeof field !== 'string') {
          this.emit('error', Error('Formatter must return a string, null or undefined'));
          return null;
        }
        containsdelimiter = field.indexOf(delimiter) >= 0;
        containsQuote = (quote !== '') && field.indexOf(quote) >= 0;
        containsEscape = field.indexOf(escape) >= 0 && (escape !== quote);
        containsRowDelimiter = field.indexOf(this.options.record_delimiter) >= 0;
        quoted = this.options.quoted;
        quotedString = this.options.quoted_string && typeof record[i] === 'string';
        quotedMatch = this.options.quoted_match && typeof record[i] === 'string' && this.options.quoted_match.filter(function(quoted_match) {
          if (typeof quoted_match === 'string') {
            return record[i].indexOf(quoted_match) !== -1;
          } else {
            return quoted_match.test(record[i]);
          }
        });
        quotedMatch = quotedMatch && quotedMatch.length > 0;
        shouldQuote = containsQuote || containsdelimiter || containsRowDelimiter || quoted || quotedString || quotedMatch;
        if (shouldQuote && containsEscape) {
          regexp = escape === '\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');
          field = field.replace(regexp, escape + escape);
        }
        if (containsQuote) {
          regexp = new RegExp(quote, 'g');
          field = field.replace(regexp, escape + quote);
        }
        if (shouldQuote) {
          field = quote + field + quote;
        }
        newrecord += field;
      } else if (this.options.quoted_empty || ((this.options.quoted_empty == null) && record[i] === '' && this.options.quoted_string)) {
        newrecord += quote + quote;
      }
      if (i !== record.length - 1) {
        newrecord += delimiter;
      }
    }
    record = newrecord;
  }
  return record;
};

// ## `Stringifier.prototype.headers`

// Print the header line if the option "header" is "true".
Stringifier.prototype.headers = function() {
  var headers;
  if (!this.options.header) {
    return;
  }
  if (!this.options.columns) {
    return;
  }
  headers = this.options.columns.map(function(column) {
    return column.header;
  });
  if (this.options.eof) {
    headers = this.stringify(headers) + this.options.record_delimiter;
  } else {
    headers = this.stringify(headers);
  }
  return this.push(headers);
};

// ## `Stringifier.prototype.headers`

// Print the header line if the option "header" is "true".
Stringifier.normalize_columns = function(columns) {
  var column, k, v;
  if (columns == null) {
    return null;
  }
  if (columns != null) {
    if (typeof columns !== 'object') {
      throw Error('Invalid option "columns": expect an array or an object');
    }
    if (!Array.isArray(columns)) {
      columns = (function() {
        var results;
        results = [];
        for (k in columns) {
          v = columns[k];
          results.push({
            key: k,
            header: v
          });
        }
        return results;
      })();
    } else {
      columns = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = columns.length; j < len; j++) {
          column = columns[j];
          if (typeof column === 'string') {
            results.push({
              key: column,
              header: column
            });
          } else if (typeof column === 'object' && (column != null) && !Array.isArray(column)) {
            if (!column.key) {
              throw Error('Invalid column definition: property "key" is required');
            }
            if (column.header == null) {
              column.header = column.key;
            }
            results.push(column);
          } else {
            throw Error('Invalid column definition: expect a string or an object');
          }
        }
        return results;
      })();
    }
  }
  return columns;
};

underscore = function(str) {
  return str.replace(/([A-Z])/g, function(_, match, index) {
    return '_' + match.toLowerCase();
  });
};
